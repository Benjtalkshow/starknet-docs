= Compile and deploy a contract

== Prerequisites
Ensure that the below commands are working properly on your system.

[source, bash]
----
scarb --version # To compile Cairo code
starkli  --version # To interact with Starknet
----

If either of the above commands fail, please check xref:environment_setup.adoc[Setting up your environment].

== Declaring smart contracts

Deploying a smart contract in Starknet requires two steps:

* Declaring the class of your contract, __sending your contract's code to the network.__
* Deploying a contract, __creating an instance of the code you previously declared.__

[TIP]
====
If you require an example smart contract to test with, you can use a preprepared example from the Starknet Book link:https://github.com/starknet-edu/starknetbook/blob/main/chapters/book/modules/chapter_1/pages/contracts/src/lib.cairo[here].
====

You can compile a smart contract using the Scarb compiler.

To compile a smart contract, create a directory containing your contract source code and a `Scarb.toml` file.

Add the following code to the `Scarb.toml` file:

[source,toml]
----
[package]
name = "contracts"
version = "0.1.0"

[dependencies]
starknet = ">=2.0.1"

[[target.starknet-contract]]
sierra = true
----

Navigate into the newly created directory:
[source,bash]
----
cd <dir_name>
----

Run the following command:

[source,bash]
----
scarb build
----

The compiled contract will be saved in the `target/dev/` directory as `contracts_Ownable.sierra.json`.

The contract is now compiled and ready to be deployed. Next you will need to declare an RPC provider within your contract.

==== Declare an RPC provider

An RPC provider needs to be defined within a smart contract in order for it to be deployed.

The following are the RPC providers available for Starknet:


===== Starknet Sequencer's Gateway
The default an easiest option is to use Starknet Sequencer's Gateway.

===== Infura or Alchemy
Use a provider like Infura or Alchemy.

===== Custom configuration
Set up your own node and use the RPC provider of your node. More information on this can be found within the link:https://book.starknet.io/chapter_4/node.html[Starknet Book].

For demonstration purposes, the Starknet Sequencer's Gateway is used in the below steps.


[source,bash]
----
starkli declare target/dev/contracts_Ownable.sierra.json --network=goerli-1 --compiler-version=2.1.0
----

The network flag is used to specify the network you want to use, it could also be `mainnet` for example. The compiler-version flag is used to specify the version of the compiler you want to use. Starkli is currently running on version `2.1.0` and `2.0.1` of the compiler.

You can know the compiler version supported by Starkli by running:

[source,bash]
----
starkli declare --help 
----

In the `--compiler-version` flag you will see possible versions of the compiler:

[source,bash]
----
--compiler-version <COMPILER_VERSION>
          Statically-linked Sierra compiler version [possible values: 2.0.1, 2.1.0]
----

However, it could be that the Scarb compiler version is 2.2.0, you can know this by running:

[source,bash]
----
scarb --version
----

This is because Starkli and Scarb are not always in sync. In this case you would need to use the compiler version that Starkli is using by installing a previous version of Scarb (check out the releases in the https://github.com/software-mansion/scarb/releases[Scarb github repo]). For example, you can do this by running the following command for installing Scarb version 0.6.1:

[source,bash]
----
curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh -s -- -v 0.6.1
----

If you get an error `Error: Invalid contract class`, it means that you are using a version of Scarb that is not supported by Starkli. In this case, you need to install a previous version of Scarb as explained above.

If you were using a provider like Infura or Alchemy, the declaration command would look like this:

[source,bash]
----
starkli declare target/dev/contracts_Ownable.sierra.json \
    --rpc=https://starknet-goerli.infura.io/v3/<API_KEY> \ 
    --compiler-version=2.1.0
----

The result of the declaration command is a contract class hash (Class hash declared:
0x00e68b4b07aeecc72f768b1c086d9b0aadce131a40a1067ffb92d0b480cf325d). This hash is the identifier of the contract class in Starknet. You can think of it as the address of the contract class. You can use a block explorer like https://testnet.starkscan.co/class/0x00e68b4b07aeecc72f768b1c086d9b0aadce131a40a1067ffb92d0b480cf325d[StarkScan] to see the contract class hash in the blockchain.

If the contract you are declaring has previously been declared by someone else, you will get an output like this:

[source,bash]
----
Not declaring class as its already declared. Class hash:
0x00e68b4b07aeecc72f768b1c086d9b0aadce131a40a1067ffb92d0b480cf325d
----

== Deploying smart contracts

Deploying a smart contract involves instantiating it on the Starknet testnet. The deployment command requires the class hash of the smart contract and any arguments expected by the constructor. For our example, the constructor expects an address to assign as the owner:

[source,bash]
----
starkli deploy \
    <CLASS_HASH> \
    <CONSTRUCTOR_INPUTS> \
    --network=goerli-1
----

With the class hash and constructor inputs, the command looks like this:

[source,bash]
----
starkli deploy \
    0x00e68b4b07aeecc72f768b1c086d9b0aadce131a40a1067ffb92d0b480cf325d \
    0x02cdAb749380950e7a7c0deFf5ea8eDD716fEb3a2952aDd4E5659655077B8510 \
    --network=goerli-1
----

After running the command and adding your password, you will see something like:

[source,bash]
----
Deploying class 0x00e68b4b07aeecc72f768b1c086d9b0aadce131a40a1067ffb92d0b480cf325d with salt 0x04bc3fc2284c8e41fb3d2a37bb0354fd0506131cc77a8c91e4e67ce3aed1d19e...
The contract will be deployed at address 0x014825acb37c36563d3b96c450afe363d2fdfa3cfbd618b323f95b68b55ebf7e
Contract deployment transaction: 0x0086972e7463d5673d8b553ae521ec2df974a97c2ce6aafc1d1c20d22c6b96c6
Contract deployed:
0x014825acb37c36563d3b96c450afe363d2fdfa3cfbd618b323f95b68b55ebf7e
----

== Interacting with a smart contract

Starkli enables interaction with smart contracts via two primary methods: 'call' for read-only functions and 'invoke' for write functions that modify the state.

=== Calling a function

The call command allows querying a smart contract function without sending a transaction. For our smart contract, we can use the get_owner function which doesn't expect any arguments and returns the address of the current owner:

[source,bash]
----
starkli call \
    0x014825acb37c36563d3b96c450afe363d2fdfa3cfbd618b323f95b68b55ebf7e \
    get_owner
    --network=goerli-1
----

As expected, it returns the address that we passed to the constructor during deployment:

[source,bash]
----
[
    "0x02cdab749380950e7a7c0deff5ea8edd716feb3a2952add4e5659655077b8510"
]
----

=== Invoking a function

To modify the state of the smart contract, we use the invoke command.

In this example, we'll invoke the transfer_ownership function to transfer the ownership from our deployer address to a different smart wallet address:

[source,bash]
----
starkli invoke \
    0x014825acb37c36563d3b96c450afe363d2fdfa3cfbd618b323f95b68b55ebf7e \
    transfer_ownership \
    0x011088d3cbe4289bc6750ee3a9cf35e52f4fa4e0ac9f42fb0b62e983139e135a \
    --network=goerli-1
----

After the transaction is accepted on L2 (you can use a block explorer like StarkScan or Voyager, and the transaction hash returned by the starkli invoke command to know the status of your transaction), we can confirm the state transition by calling the get_owner function again:

[source,bash]
----
starkli call \
    0x014825acb37c36563d3b96c450afe363d2fdfa3cfbd618b323f95b68b55ebf7e \
    get_owner \
    --network=goerli-1
----

The get_owner function now returns the new owner address, confirming the successful ownership transfer.

Congratulations! You have successfully deployed and interacted with a Starknet contract. Go to the Chapter 2 of the Starknet Book to learn more about Starknet and Cairo.
