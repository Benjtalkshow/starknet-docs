[id="deploying_new_accounts"]
= Deploying a new account

You can deploy a new account in the following ways:

* Send a `DEPLOY_ACCOUNT` transaction. This method does not require a preexisting account.
* Include the `deploy` syscall in the account contract, such as by invoking the Universal Deployer Contract (UDC) with an `INVOKE` transaction. This method requires an existing account to send the `INVOKE` transaction.

== Deploying a new account with the `DEPLOY_ACCOUNT` transaction type

The `DEPLOY_ACCOUNT` transaction deploys new accounts to the network.

Upon receiving a `DEPLOY_ACCOUNT` transaction, the sequencer performs the following steps:

. Verifies that the address has funds to pay for the deployment.
. Executes the constructor with the given arguments.
. Executes the `+__validate_deploy__+` entry point. For more information, see xref:#validate_deploy[].
. Charges fees from the new account address.
. Sets the account's nonce to `1`.

*To create and deploy a new account*, you can use Starkli's `starkli account` command.

For more information, see link:https://book.starkli.rs/accounts[Accounts] in the Starkli Book.
For information on how to starkli to create and deploy a new account.

// After the deployment has completed successfully, it is recommended to validate the account deployment using .

[#DEPLOY_ACCOUNT_restrictions]
== `DEPLOY_ACCOUNT` constructor restrictions

The constructor of the `DEPLOY_ACCOUNT` transaction has the following limitations:

* Restricted access to `sequencer_address` in the `get_execution_info` syscall. The syscall returns zero values for `sequencer_address`
* Restricted access to the following syscalls:
** `get_block_hash` for Cairo contracts
** `get_sequencer_address` for Cairo 0 contracts

[#validate_deploy]
== Validation of a `DEPLOY_ACCOUNT` transaction

A `DEPLOY_ACCOUNT` transaction automatically tells the sequencer to call the `+__validate_deploy__+` function, which validates the transaction.

[NOTE]
====
When creating a new account without the `DEPLOY_ACCOUNT` transaction, such as by invoking the Universal Deployer Contract (UDC) with an `INVOKE` transaction, the sequencer calls the `+__validate__+` function, which validates the `INVOKE` transaction.
====

'''

.Solidity Example
[source,solidity]
----
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0 <0.9.0;

library Balances {
    function move(mapping(address => uint256) storage balances, address from, address to, uint amount) internal {
        require(balances[from] >= amount);
        require(balances[to] + amount >= balances[to]);
        balances[from] -= amount;
        balances[to] += amount;
    }
}

contract Token {
    mapping(address => uint256) balances;
    using Balances for *;
    mapping(address => mapping(address => uint256)) allowed;

    event Transfer(address from, address to, uint amount);
    event Approval(address owner, address spender, uint amount);

    function transfer(address to, uint amount) external returns (bool success) {
        balances.move(msg.sender, to, amount);
        emit Transfer(msg.sender, to, amount);
        return true;

    }

    function transferFrom(address from, address to, uint amount) external returns (bool success) {
        require(allowed[from][msg.sender] >= amount);
        allowed[from][msg.sender] -= amount;
        balances.move(from, to, amount);
        emit Transfer(from, to, amount);
        return true;
    }

    function approve(address spender, uint tokens) external returns (bool success) {
        require(allowed[msg.sender][spender] == 0, "");
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function balanceOf(address tokenOwner) external view returns (uint balance) {
        return balances[tokenOwner];
    }
}
----