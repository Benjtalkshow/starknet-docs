[id="deploying_new_accounts"]
= Deploying a new account

The `DEPLOY_ACCOUNT` transaction deploys new accounts to the network.

Upon receiving a `DEPLOY_ACCOUNT` transaction, the sequencer performs the following steps:

. Verifies that the address has funds to pay for the deployment.
. Executes the constructor with the given arguments.
. Executes the `+__validate_deploy__+` entry point. For more information, see xref:#validate_deploy[].
. Charges fees from the new account address.
. Sets the account's nonce to `1`.

.Procedure

. Decide on the account contract that you want to deploy.
. Compute your offchain account address.
// How do I do that?
. Send funds to this address.
// How do I do that?
. When the address has enough funds to pay for the deployment, send a `DEPLOY_ACCOUNT` transaction.
// How do I do that?

After the deployment has completed successfully, it is recommended to validate the account deployment.

[#validate_deploy]
== Validating a `DEPLOY_ACCOUNT` transaction

Two potential issues with sending a `DEPLOY_ACCOUNT` transaction without any validation are:

* Sequencers can charge arbitrarily high fees, potentially draining user funds from a pre-funded account.
* A bad actor can carry out a Denial of Service (DoS) attack on the sequencer by sending multiple, invalid `DEPLOY_ACCOUNT` transactions, which would result in the sequencer not being compensated for work completed.

You can prevent both issues by using a validation entrypoint called `+__validate_deploy__+`.

`+__validate_deploy__+` prevents sequencers from charging arbitrarily high fees, and the following limitations on the constructor and `+__validate_deploy__+` executions prevent a potential DoS attack:

* Limited number of Cairo steps.
* Limited number of builtin applications.
* External contract calls are not allowed. Library calls and self-calls are allowed.

Include the `+__validate_deploy__+` entrypoint in any accounts or contracts that can enable deploying a new account.

== `+__validate_deploy__+`

Validates a `DEPLOY_ACCOUNT` transaction.

[discrete]
=== Parameters

[horizontal,labelwidth="35",role="stripes-odd"]
`class_hash: _felt_`:: The class hash.
`contract_address_salt: _felt_`:: The contract address salt.
`<__constructor_arguments__>`:: The arguments expected by the contractâ€™s constructor. The compiler enforces this constructor.

[NOTE]
====
In determining the contract address, the deployer address `0x0` is used.
====

[discrete]
=== Example
Consider an account with the following constructor signature:

[#constructor_signature]
[source,cairo]
----
@constructor
func constructor{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    _public_key: felt
)
----

The signature of `+__validate_deploy__+` must be:

[#call_validate_deploy]
[source,cairo,sub="quotes"]
----
func __validate_deploy__{
    syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr, ecdsa_ptr: SignatureBuiltin*
}(class_hash: felt, contract_address_salt: felt, _public_key: felt)
----

[NOTE]
====
You can access the transaction hash and value for `max_fee` with the `get_tx_info` system call.
====
